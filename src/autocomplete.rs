// AUTOGENERATED COMPONENT by LLM

use crate::{
    dom_struct::DomStruct,
    dom_text::DomText,
    dom_vec::DomVec,
    jet::{AccessToken, Component, ElementFactory, WithElement},
    visited_operators::get_all_instruction_names,
};
use std::rc::Rc;
use web_sys::HtmlDivElement;

type SuggestionItem = DomStruct<(DomText, ()), HtmlDivElement>;
type SuggestionList = DomVec<SuggestionItem, HtmlDivElement>;

pub struct Autocomplete {
    component: SuggestionList,
    all_candidates: Rc<Vec<String>>,
    visible: bool,
    selected_index: Option<usize>,
    on_select: Option<Rc<dyn Fn(String)>>,
}

impl Autocomplete {
    pub fn set_on_select<F: Fn(String) + 'static>(&mut self, f: F) {
        self.on_select = Some(Rc::new(f));
    }

    pub fn new(factory: ElementFactory) -> Self {
        let mut list = DomVec::new(factory.div());
        list.set_attribute("class", "autocomplete-list");
        list.set_attribute("style", "display: none;");

        let mut candidates = get_all_instruction_names();
        candidates.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));

        Self {
            component: list,
            all_candidates: Rc::new(candidates),
            visible: false,
            selected_index: None,
            on_select: None,
        }
    }

    pub fn filter(&mut self, prefix: &str, factory: &ElementFactory, _left: f64, _top: f64) {
        if prefix.is_empty() {
            self.hide();
            return;
        }

        self.component.clear();
        self.selected_index = None;
        let mut count = 0;
        let mut exact_match = false;

        for candidate in self.all_candidates.iter() {
            if candidate == prefix {
                exact_match = true;
            }
            if candidate.starts_with(prefix) {
                let mut item: SuggestionItem =
                    DomStruct::new((DomText::new(candidate), ()), factory.div());
                item.set_attribute("class", "suggestion-item");

                if let Some(on_select) = &self.on_select {
                    let on_select = on_select.clone();
                    let candidate = candidate.clone();
                    item.set_onmousedown(move |ev: web_sys::MouseEvent| {
                        ev.prevent_default();
                        on_select(candidate.clone())
                    });
                }

                self.component.push(item);
                count += 1;
            }
        }

        // Don't show if the only match is what we already typed
        if count == 1 && exact_match {
            self.hide();
            return;
        }

        if count > 0 {
            self.show(0.0, 0.0);
            self.select_index(Some(0));
        } else {
            self.hide();
        }
    }

    pub fn select_next(&mut self) {
        if !self.visible || self.component.is_empty() {
            return;
        }
        let new_idx = match self.selected_index {
            Some(i) => (i + 1) % self.component.len(),
            None => 0,
        };
        self.select_index(Some(new_idx));
    }

    pub fn select_prev(&mut self) {
        if !self.visible || self.component.is_empty() {
            return;
        }
        let len = self.component.len();
        let new_idx = match self.selected_index {
            Some(i) => (i + len - 1) % len,
            None => len - 1,
        };
        self.select_index(Some(new_idx));
    }

    fn select_index(&mut self, index: Option<usize>) {
        if let Some(old) = self.selected_index
            && let Some(item) = self.component.get_mut(old)
        {
            item.remove_attribute("selected");
            let cls = item.get_attribute("class").cloned().unwrap_or_default();
            item.set_attribute("class", &cls.replace(" selected", ""));
        }

        self.selected_index = index;

        if let Some(new) = self.selected_index
            && let Some(item) = self.component.get_mut(new)
        {
            item.set_attribute("selected", "true");
            let cls = item.get_attribute("class").cloned().unwrap_or_default();
            item.set_attribute("class", &(cls + " selected"));
        }
    }

    pub fn get_selected(&self) -> Option<String> {
        if let Some(idx) = self.selected_index {
            self.component
                .get(idx)
                .map(|item: &SuggestionItem| item.get().0.get().to_string())
        } else {
            None
        }
    }

    pub fn show(&mut self, _left: f64, _top: f64) {
        self.component.remove_attribute("style");
        self.visible = true;
    }

    pub fn hide(&mut self) {
        self.component.set_attribute("style", "display: none;");
        self.visible = false;
    }

    pub fn is_visible(&self) -> bool {
        self.visible
    }
}

impl WithElement for Autocomplete {
    type Element = HtmlDivElement;
    fn with_element(&self, f: impl FnMut(&HtmlDivElement), g: AccessToken) {
        self.component.with_element(f, g)
    }
}

impl Component for Autocomplete {
    fn audit(&self) {
        self.component.audit();
    }
}

pub fn suggest(prefix: &str, limit: usize) -> Vec<String> {
    if prefix.is_empty() {
        return Vec::new();
    }
    get_all_instruction_names()
        .into_iter()
        .filter(|s| s.starts_with(prefix) && s != prefix)
        .take(limit)
        .collect()
}

pub fn completion_suffix<'a>(full: &'a str, prefix: &str) -> &'a str {
    &full[prefix.trim_start().len()..]
}
