// AUTOGENERATED COMPONENT by LLM

use crate::{
    dom_struct::DomStruct,
    dom_text::DomText,
    dom_vec::DomVec,
    jet::{AccessToken, Component, ElementFactory, WithElement},
    visited_operators::get_all_instruction_names,
};
use std::rc::Rc;
use web_sys::HtmlDivElement;

type SuggestionItem = DomStruct<(DomText, ()), HtmlDivElement>;
type SuggestionList = DomVec<SuggestionItem, HtmlDivElement>;

pub struct Autocomplete {
    component: SuggestionList,
    all_candidates: Rc<Vec<String>>,
    visible: bool,
    selected_index: Option<usize>,
}

impl Autocomplete {
    pub fn new(factory: ElementFactory) -> Self {
        let mut list = DomVec::new(factory.div());
        list.set_attribute("class", "autocomplete-list");
        list.set_attribute("style", "display: none;");

        Self {
            component: list,
            all_candidates: Rc::new(get_all_instruction_names()),
            visible: false,
            selected_index: None,
        }
    }

    pub fn filter(&mut self, prefix: &str, factory: &ElementFactory, left: f64, top: f64) {
        if prefix.is_empty() {
            self.hide();
            return;
        }

        self.component.clear();
        self.selected_index = None;
        let mut count = 0;
        let mut exact_match = false;

        for candidate in self.all_candidates.iter() {
            if candidate == prefix {
                exact_match = true;
            }
            if candidate.starts_with(prefix) {
                let mut item: SuggestionItem =
                    DomStruct::new((DomText::new(candidate), ()), factory.div());
                item.set_attribute("class", "suggestion-item");
                self.component.push(item);
                count += 1;
                if count >= 10 {
                    break;
                }
            }
        }

        // Don't show if the only match is what we already typed
        if count == 1 && exact_match {
            self.hide();
            return;
        }

        if count > 0 {
            self.show(left, top);
            self.select_index(Some(0));
        } else {
            self.hide();
        }
    }

    pub fn select_next(&mut self) {
        if !self.visible || self.component.is_empty() {
            return;
        }
        let new_idx = match self.selected_index {
            Some(i) => (i + 1) % self.component.len(),
            None => 0,
        };
        self.select_index(Some(new_idx));
    }

    pub fn select_prev(&mut self) {
        if !self.visible || self.component.is_empty() {
            return;
        }
        let len = self.component.len();
        let new_idx = match self.selected_index {
            Some(i) => (i + len - 1) % len,
            None => len - 1,
        };
        self.select_index(Some(new_idx));
    }

    fn select_index(&mut self, index: Option<usize>) {
        if let Some(old) = self.selected_index
            && let Some(item) = self.component.get_mut(old)
        {
            item.remove_attribute("selected");
            let cls = item.get_attribute("class").cloned().unwrap_or_default();
            item.set_attribute("class", &cls.replace(" selected", ""));
        }

        self.selected_index = index;

        if let Some(new) = self.selected_index
            && let Some(item) = self.component.get_mut(new)
        {
            item.set_attribute("selected", "true");
            let cls = item.get_attribute("class").cloned().unwrap_or_default();
            item.set_attribute("class", &(cls + " selected"));
        }
    }

    pub fn get_selected(&self) -> Option<String> {
        if let Some(idx) = self.selected_index {
            self.component
                .get(idx)
                .map(|item: &SuggestionItem| item.get().0.get().to_string())
        } else {
            None
        }
    }

    pub fn show(&mut self, left: f64, top: f64) {
        let style = format!("left: {}px; top: {}px;", left, top);
        self.component.set_attribute("style", &style);
        self.visible = true;
    }

    pub fn hide(&mut self) {
        self.component.set_attribute("style", "display: none;");
        self.visible = false;
    }

    pub fn is_visible(&self) -> bool {
        self.visible
    }
}

impl WithElement for Autocomplete {
    type Element = HtmlDivElement;
    fn with_element(&self, f: impl FnMut(&HtmlDivElement), g: AccessToken) {
        self.component.with_element(f, g)
    }
}

impl Component for Autocomplete {
    fn audit(&self) {
        self.component.audit();
    }
}
